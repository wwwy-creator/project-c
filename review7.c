//chapter8 指针
//指针与地址   指针变量的定义   指针运算   多及指针概念   一维数组的地址表示   指向数据元素的指针   指针作为函数参数   
//二维数组的地址表示   一级指针访问二位数组   行指针访问二维数组   行指针作为函数参数   指向函数的指针   返回指针的函数 
/*1.指针与地址   由于地址唯一确定程序实体的存储位置，就像路标一样，故将地址称为指针
指针变量是专门存放变量（或其他程序体）地址的变量     指针变量也需要存储单元
*/
/*2.指针变量的定义    类型名：*指针变量名1，*指针变量名2，......；   类型名指定指针变量指向的程序实体（变量、数组）的类
型必须是有效的数据类型，由类型名可确定程序实体所占内存的字节数，当指针变量移动时以这个字节为单位。
赋值：初始化赋值和在程序执行部分赋值俩种     初始化赋值：类型  *指针变量名=&变量名，......;  
*/
/*3.指针运算   指针变量的赋值运算      指向运算（指向运算符 * , *运算符和取地址运算符&互逆)    指针算数运算和关系运算(重
要运算） 
#include<stdio.h>
int main()
{
	int a,b,c,*p1,*p2;
	p1=&a,p2=&b;
	printf("请输入俩个大小不同整数：");
	scanf("%d%d",p1,p2);
	if(a>b){
		c=*p2;*p2=*p1;*p1=c;
	}
	printf("%3d%3d\n",a,b);
	return 0;
}
*/
/*4.多及指针概念   指针变量的存储单元也有地址，由于存放的也是地址，故也是指针变量。由于存放的是指针变量的地址，故称为二
级指针
定义：类型  **指针变量名;       多级指针以此类推
*/
/*5.一维数组的地址表示    数组名为数组的首地址常量，用它组成的地址表达式可以表示所有元素的地址   
俩种元素表示方法：a[i]下标法、*(a+i)地址法、*(p+i)指针变量法(指针变量的下标运算法和它等价)    三种方法效率依次增高
#include<stdio.h>
int main()
{
	int a[10],i,*p=a;
	printf("请输入10个任意整数：\n");
	for(i=0;i<10;i++){
		scanf("%d",&a[i]);
	}
	for(i=0;i<10;i++){        //下标法 
		printf("%3d",a[i]);
	}
	printf("\n");
	for(i=0;i<10;i++){        //地址法 
		printf("%3d",*(a+i));
	}
	printf("\n");
	for(;p<a+10;p++){        //指针变量法 
		printf("%3d",*p);
	}
	printf("\n");
	p=a;                     //指针下标法     由于p指向的地址已经不是&a[0]，所以要重新赋值 
	for(i=0;i<10;i++){       
		printf("%3d",p[i]);
	}
	printf("\n");
	return 0;
}
*/
/*6.指向数据元素的指针    同一维数组的地址表示*/
/*7.指针作为函数参数    与第六章的地址传递相挂钩   地址传递是将数据的存储地址作为实参传递给形参，形参类型必须是指针变
量或数组实参只能是变得地址、数组名、指针变量    地址传递是单向性的，即形参存放地址的改变不会使得实参所存地址发生改变
#include<stdio.h>
int main()
{
	void ast(int x,int y,int *c,int *d);
	int swap(int *a,int *b);
	int a=4,b=3,c,d;
	ast(a,b,&c,&d);
	printf("%d,%d\n",c,d);   //地址传递，地址指向的变量值是可以被改变的 
	printf("%ld\n",&a);	     //地址传递的单向性
	swap(&a,&b);
	printf("%ld\n",&a);	
	return 0;
}
void ast(int x,int y,int *c,int *d)
{
	*c=x+y;*d=x-y;
}
int swap(int *a,int *b)
{
	int *p;
	p=b;b=a;a=p;
	printf("%ld\n",a);
	return 0; 
}
*/
/*8.二维数组的地址表示   c语言规定二维数组由一维数组扩展形成：二维数组名a，是二级指针常量（行指针，注意：和普通二级指针有
区别，解释在下方119行），存储列指针的地址，*a==a[0]、*(a+1)==a[1]、*(a+2)==a[2]；   
以a[0](一级指针常量)为数组名，存储元素地址，**a==*a[0]==a[0][0]、*(*a+1)==*(a[0]+1)==a[0][1]、*(*a+2)==*(a[0]+2)==a[0][2]；
......*(*(a+i))==*(a[i])==a[i][0]、*(*(a+i)+1)==*(a[i]+1)==a[i][1]、*(*(a+i)+2)==*(a[i]+2)==a[i][2]
#include<stdio.h>
int main()
{
	int a[2][3]={1,2,3,4,5,6};
	//不论是一维数组还是二维，存储单元都是连续的
	printf("0行2列首地址为%u,1行0列首地址为%u\n",*a+2,*(a+1));
	return 0;
 } 
#include<stdio.h>
int main()
{
	int a[2][3]={1,2,3,4,5,6};
	printf("0行首地址为%u,0行首地址为%u\n",a,&a[0]);
	printf("0行首地址为%u,0行0列首地址为%u,0行1列首地址为%u\n",a,*a,*a+1);
	printf("1行首地址为%u,1行0列首地址为%u,1行1列首地址为%u\n",a+1,*(a+1),a[1]+1);
	printf("1行1列首地址为%u,1行1列首地址为%u,1行1列元素为%d\n",*(a+1)+1,a[1]+1,*(a[1]+1));
	return 0;
 }
***特别注意***：a是二级指针常量，存储a[0]的地址；a[0]是一级指针常量，存储a[0][0]的地址。实际上，a存储的地址值和a[0]存储的地
址值是一样的。但是，俩者级别不同。a+1是移动一行，*a+1是移动一列。设a为首地址1000，那么a+1的地址值为1016；而*a+1是1004. 
*/
/*9.一级指针访问二位数组
#include<stdio.h>
int main()
{
	int i,j,a[3][4],*p=*a;
//*****注意*****	int i,j,a[3][4],**p=a;   **p=a;语句错误：二维数组名相当于指针，但是它是一个指向数组类型
//（也就是整型或者字符型,具体取决于你数组的定义）的指针。而二级指针在真正意义上也是一个指针，但它是一个指向指针的指针。
//在寻址时，拿整型数组举例,直接引用数组名，系统会在数组名指向的地址往后寻址2个字节得到一个整型数字。而引用二级指针时，系统
//会在指针指向的地址后寻址4个字节得到一个地址，所以两个不能相互赋值。
	printf("请输入12个整数：\n"); 
//1.	for(i=0;i<3;i++){
//		for(j=0;j<4;j++)
//		scanf("%d",p+4*i+j);
//	}
//2.    for(i=4;p<*(a+3);i+=4,p+=i){
//    	for(j=0;j<4;j++)
//    	scanf("%d",p+j);
//	}
//3.    for(i=0;i<12;i++) scanf("%d",p+i); 
	for(i=0;i<3;i++){
		for(j=0;j<4;j++)
		printf("%3d",a[i][j]);
	}
	return 0;
}
*/
/*10.行指针访问二维数组   行指针是二级指针，指向由一行元素组成的数组（列指针指向元素）
定义指向一维数组的指针变量（二级指针变量）：类型 （*指针名）[一维数组元素个数]；    括号不能少，否则将定义一个指针数组
#include<stdio.h>
int main()
{
	int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};
	//int (*p)[4],row,col;
	//p=a;
	int (*p)[4]=a,row,col;
	printf("请输入数组a[3][4]的任意行列号：\n");
	scanf("%d%d",&row,&col);
	printf("a[%d][%d]=%d\n",row,col,*(*(p+row)+col));
	return 0;
}
*/
/*11.行指针作为函数参数
#include<stdio.h>
int main()
{
	int a[3][3],i,min,row,col;
	int amin(int (*p)[3],int *mrow,int *mcol);
	printf("请输入9个任意整数：\n");
	for(i=0;i<9;i++) scanf("%d",a[0]+i);
    min=amin(a,&row,&col);
	printf("最小值是%d，行号是%d，列号是%d\n",min,row,col);
	return 0;
}
int amin(int (*p)[3],int *mrow,int *mcol)
{
	int i,j,min=p[0][0];
	for(i=0;i<3;i++){
		for(j=0;j<3;j++)
		if(p[i][j]<min) {
			min=p[i][j];*mrow=i;*mcol=j;
		}
	}
	return min;
}
*/
/*12.指向函数的指针   函数在内存一段连续的存储区域的首字节编号叫做函数的入口地址，又叫做函数指针。c语言中函数指针用函数名
表示，它是一个地址常量。c语言可以通过定义指向函数的指针变量来访问函数，实现函数的间接访问。

用指向函数的指针变量来调用函数    定义：函数返回值类型  (*指针变量名)(形参表)；  形参表可省，但前后括号都不可省。   使用方
法：先定义指向函数的指针变量，然后给指针变量赋函数入口地址（即函数名），最后调用函数，形式为  （*指针名）（实参列表）
使用情况：有选择的整型函数（如实现菜单功能）或者多次调用同类型的一些函数做相同的工作 
#include<stdio.h>
int main()
{
	int a,b,maxx;
	int max(int c,int d);
	int (*p)();//形参表可省，但括号不可省 
	p=max;
	printf("输入俩个大小不同的整数："); 
	scanf("%d%d",&a,&b);
	maxx=(*p)(a,b);
	printf("较大值为%d\n",maxx);
	return 0;
}
int max(int c,int d)
{
	return (c>d?c:d);
}
函数指针做函数参数   函数名做参数   设计工作函数 
*/
/*13.返回指针的函数   定义：类型  *函数名（类型  形参1，类型  形参2，....） {......函数体.....}
注意区分指向函数的指针 (*p)() 和返回指针的函数 *p()     */
/*
区分字符指针数组和二维字符数组，并且注意，指针数组存储的是字符串首字母首地址，指向的是存在全局静态区的常量，指向的地址的值不
能被更改。 
#include<stdio.h>
int main()
{
	char *arr[5]={"acs","shcb","xbs","bcsua","eud"};
char *ar="absd";
	printf("%d\n",ar);//字符串"absd"的首地址 
	printf("%d\n",ar+1);
	printf("%d\n",arr[0]);
	printf("%c\n",*arr[0]);//字符指针数组a[0]指向的地址所存的值 
	printf("%d\n",arr[0]+1);
	return 0;
}
*/

